---
import Layout from "../layouts/Layout.astro";

const slides = [
  "/projects/01 Project One.png",  
  "/projects/02 Project Two.png",
  "/projects/03 Project Three.png",
  "/projects/04 Project Four.png",
  "/projects/05 Project Five.png",
  "/projects/06 Project Six.png",
];
---

<Layout title="Home" description="">
  <section class="home">
    <div class="full-bleed">
      <div class="carousel" id="projects">
        <div class="viewport" id="viewport" tabindex="0" aria-label="Projects carousel">
          <div class="window" id="window">
            <ul class="track" id="track" aria-live="polite">
              <li class="card"><img id="img-prev" alt="Previous project" decoding="async" /></li>
              <li class="card is-active" id="card-cur"><img id="img-cur" alt="Current project" decoding="async" /></li>
              <li class="card"><img id="img-next" alt="Next project" decoding="async" /></li>
            </ul>
          </div>
        </div>

        <div class="inner">
          <div class="dots" id="dots" role="tablist" aria-label="Project slide navigation">
            {slides.map((_, i) => (
              <button class="dot" type="button" data-index={i} aria-label={`Go to slide ${i + 1}`} />
            ))}
          </div>
        </div>
      </div>
    </div>
  </section>

  <script define:vars={{ slides }}>
    const viewport = document.getElementById("viewport");
    const track = document.getElementById("track");
    const dots = document.querySelectorAll("#dots .dot");

    const cardCur = document.getElementById("card-cur");

    const imgPrev = document.getElementById("img-prev");
    const imgCur  = document.getElementById("img-cur");
    const imgNext = document.getElementById("img-next");

    const n = slides.length;
    const mod = (x) => (x % n + n) % n;

    let index = 0;
    let animating = false;
    let baseX = 0;

    // -------------------------
    // ✅ Preload + decode cache
    // -------------------------
    const preloadCache = new Map();

    const preload = (src) => {
      if (!src) return Promise.resolve();
      if (preloadCache.has(src)) return preloadCache.get(src);

      const p = new Promise((resolve) => {
        const im = new Image();
        im.decoding = "async";
        im.loading = "eager";
        im.src = src;

        const done = () => resolve(true);

        // decode() prevents flicker on advance (when supported)
        if (im.decode) {
          im.decode().then(done).catch(() => {
            // decode can fail on some formats/browsers; fall back to load
            if (im.complete) done();
            else im.addEventListener("load", done, { once: true });
            im.addEventListener("error", done, { once: true });
          });
        } else {
          if (im.complete) done();
          else im.addEventListener("load", done, { once: true });
          im.addEventListener("error", done, { once: true });
        }
      });

      preloadCache.set(src, p);
      return p;
    };

    // Preload all slides (small set, simplest)
    const preloadAll = async () => {
      await Promise.all(slides.map(preload));
    };

    // Preload neighborhood (keeps things warm while you navigate)
    const preloadNeighbors = (i) => {
      preload(slides[mod(i - 1)]);
      preload(slides[mod(i)]);
      preload(slides[mod(i + 1)]);
      preload(slides[mod(i + 2)]);
    };

    const setDots = () => {
      dots.forEach((d, i) => {
        if (i === index) d.setAttribute("data-active", "true");
        else d.removeAttribute("data-active");
        d.setAttribute("aria-selected", i === index ? "true" : "false");
      });
    };

    // Set images (assumes they've been preloaded)
    const setImages = () => {
      imgPrev.src = slides[mod(index - 1)];
      imgCur.src  = slides[index];
      imgNext.src = slides[mod(index + 1)];

      // keep decode async; preloader does the heavy lifting
      imgCur.decoding = "async";
      imgPrev.decoding = "async";
      imgNext.decoding = "async";
    };

    const gapPx = () => {
      const cs = getComputedStyle(track);
      return parseFloat(cs.columnGap || cs.gap || "0") || 0;
    };

    const cardWidth = () => {
      const card = track.querySelector(".card");
      return card ? card.getBoundingClientRect().width : 0;
    };

    const stepDistance = () => Math.round(cardWidth() + gapPx());

    // ✅ compute baseX so current card center == viewport center
    const computeBaseX = () => {
      const v = viewport.getBoundingClientRect();
      const c = cardCur.getBoundingClientRect();

      const viewportCenter = v.left + v.width / 2;
      const cardCenter = c.left + c.width / 2;

      baseX += (viewportCenter - cardCenter);
      baseX = Math.round(baseX);

      track.style.transition = "none";
      track.style.transform = `translate3d(${baseX}px, 0, 0)`;
      track.offsetHeight;
    };

    const snap = () => {
      track.style.transition = "none";
      track.style.transform = `translate3d(${baseX}px, 0, 0)`;
      track.offsetHeight;
      computeBaseX();
    };

    const step = async (dir) => {
      if (animating) return;
      animating = true;

      const nextIndex = mod(index + dir);

      // ✅ ensure target + neighbors are ready BEFORE animating
      await Promise.all([
        preload(slides[mod(nextIndex - 1)]),
        preload(slides[nextIndex]),
        preload(slides[mod(nextIndex + 1)]),
      ]);

      const dist = stepDistance();

      track.style.transition = "transform 320ms ease";
      track.style.transform = `translate3d(${baseX + (dir === 1 ? -dist : dist)}px, 0, 0)`;

      const onDone = () => {
        track.removeEventListener("transitionend", onDone);

        index = nextIndex;
        setDots();
        setImages();
        snap();

        // keep warming cache
        preloadNeighbors(index);

        animating = false;
      };

      track.addEventListener("transitionend", onDone);
    };

    const goTo = async (t) => {
      t = mod(t);
      if (t === index || animating) return;
      animating = true;

      // preload target neighborhood
      await Promise.all([
        preload(slides[mod(t - 1)]),
        preload(slides[t]),
        preload(slides[mod(t + 1)]),
      ]);

      index = t;
      setDots();
      setImages();
      requestAnimationFrame(() => {
        computeBaseX();
        preloadNeighbors(index);
        animating = false;
      });
    };

    dots.forEach((dot) => {
      dot.addEventListener("click", () => {
        const t = Number(dot.getAttribute("data-index"));
        goTo(t);
      });
    });

    // Wheel direction: down/right = next, up/left = prev
    let wheelLock = false;
    viewport.addEventListener(
      "wheel",
      (e) => {
        e.preventDefault();
        if (wheelLock || animating) return;
        wheelLock = true;

        const dominant = Math.abs(e.deltaY) >= Math.abs(e.deltaX) ? e.deltaY : e.deltaX;
        step(dominant > 0 ? 1 : -1);

        setTimeout(() => (wheelLock = false), 360);
      },
      { passive: false }
    );

    // Drag / swipe
    let startX = 0;
    let dragging = false;

    viewport.addEventListener("pointerdown", (e) => {
      if (animating) return;
      dragging = true;
      startX = e.clientX;
      viewport.setPointerCapture?.(e.pointerId);
    });

    viewport.addEventListener("pointerup", (e) => {
      if (!dragging || animating) return;
      dragging = false;

      const dx = e.clientX - startX;
      const threshold = Math.min(90, viewport.clientWidth * 0.14);

      if (dx < -threshold) step(1);
      else if (dx > threshold) step(-1);
    });

    viewport.addEventListener("pointercancel", () => {
      dragging = false;
    });

    // Keyboard
    viewport.addEventListener("keydown", (e) => {
      if (animating) return;
      if (e.key === "ArrowRight") step(1);
      if (e.key === "ArrowLeft") step(-1);
    });

    // resize
    let resizeT;
    window.addEventListener("resize", () => {
      clearTimeout(resizeT);
      resizeT = setTimeout(() => computeBaseX(), 60);
    });

    // Init
    (async () => {
      // ✅ preload everything up-front (fast with 5 images)
      preloadAll();

      // preload neighbors too (immediate warmth)
      preloadNeighbors(index);

      // set initial images
      setImages();
      setDots();

      requestAnimationFrame(() => {
        baseX = 0;
        track.style.transform = "translate3d(0,0,0)";
        computeBaseX();
      });
    })();
  </script>

  <style>
    .home{
      display: grid;
      gap: 16px;
      width: 100%;
      padding-top: clamp(12px, 3vh, 28px);
      padding-bottom: clamp(18px, 4vh, 44px);
    }

    .carousel{ width: 100%; }

    .viewport{
      width: 100%;
      overflow: hidden;
      outline: none;
      touch-action: pan-y;
      box-sizing: border-box;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .window{
      width: clamp(320px, 78vw, 980px);
      overflow: visible; /* allow next peek */
    }

    .track{
      display: flex;
      align-items: center;
      gap: clamp(10px, 2vw, 18px);
      padding: 6px 0;
      will-change: transform;
      transform: translate3d(0,0,0);
    }

    .card{
      flex: 0 0 auto;
      width: clamp(320px, 78vw, 980px);
      border-radius: 16px;
      overflow: hidden;
      aspect-ratio: 16 / 9;
      background: var(--card);
      border: 1px solid var(--border);
      transform: scale(0.94);
      opacity: 0.85;
      transition: transform 200ms ease, opacity 200ms ease;
    }

    .card.is-active{
      transform: scale(1);
      opacity: 1;
    }

    .card img{
      width: 100%;
      height: 100%;
      display: block;
      object-fit: contain;
      object-position: center;
      user-select: none;
      -webkit-user-drag: none;
    }

    .dots{
      margin-top: 0.9rem;
      display: flex;
      justify-content: center;
      gap: 10px;
      width: 100%;
    }

    .dot{
      width: 10px;
      height: 10px;
      border-radius: 999px;
      border: 0;
      background: currentColor;
      opacity: 0.35;
      cursor: pointer;
      transition: transform 160ms ease, opacity 160ms ease;
      position: relative;
    }

    .dot[data-active="true"]{
      opacity: 1;
      transform: scale(1.35);
    }

    .dot::before{
      content: "";
      position: absolute;
      inset: -10px;
    }
  </style>
</Layout>
