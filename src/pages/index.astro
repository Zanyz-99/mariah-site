---
import Layout from "../layouts/Layout.astro";

const slides = [
  "/projects/02 Project Two.png",
  "/projects/03 Project Three.png",
  "/projects/04 Project Four.png",
  "/projects/05 Project Five.png",
  "/projects/06 Project Six.png",
];
---

<Layout title="Home" description="">
  <section class="content home-wrap">
    <div class="projects" id="projects">
      <div class="viewport" aria-label="Projects carousel">
        <ul class="track" id="track">
          {slides.map((src, i) => (
            <li class="slide" data-i={i}>
              <img
                src={src}
                alt={`Project ${i + 1}`}
                loading={i === 0 ? "eager" : "lazy"}
                decoding="async"
              />
            </li>
          ))}
        </ul>
      </div>

      <div class="dots" id="dots" role="tablist" aria-label="Project slide navigation">
        {slides.map((_, i) => (
          <button class="dot" type="button" data-index={i} aria-label={`Go to slide ${i + 1}`} />
        ))}
      </div>
    </div>
  </section>

  <script>
    const root = document.getElementById("projects");
    const viewport = root.querySelector(".viewport");
    const track = document.getElementById("track");
    const dots = document.querySelectorAll("#dots .dot");

    // State
    let index = 0;           // logical index 0..n-1
    let animating = false;

    // --- Setup: make it circular by moving last slide to front initially
    const normalize = (i, n) => (i % n + n) % n;
    const setActiveDot = () => {
      dots.forEach((d, i) => {
        if (i === index) d.setAttribute("data-active", "true");
        else d.removeAttribute("data-active");
      });
    };

    // We keep the "current" slide always visually centered by:
    // 1) placing the current slide in the middle position
    // 2) animating translateX for the slide change
    // 3) when animation ends, we rotate DOM nodes (NO scroll jump; no visible teleport)
    //
    // This is a standard seamless looping trick.
    const rotateToIndex = (nextIndex, dir) => {
      if (animating) return;
      animating = true;

      const n = track.children.length;
      index = normalize(nextIndex, n);
      setActiveDot();

      // Animate: shift track left/right by 100% of viewport
      // dir = +1 means move to next (track slides left)
      // dir = -1 means move to prev (track slides right)
      track.style.transition = "transform 320ms ease";
      track.style.transform = `translateX(${dir * -100}%)`;

      const onDone = () => {
        track.removeEventListener("transitionend", onDone);

        // After movement, rotate DOM children so the "current" slide is back at center.
        // Reset transform instantly (no transition), then re-enable transitions.
        track.style.transition = "none";
        track.style.transform = "translateX(-100%)";

        if (dir === 1) {
          // moved next: first visible was center->left, so move first child to end
          track.appendChild(track.firstElementChild);
        } else {
          // moved prev: last child becomes first
          track.insertBefore(track.lastElementChild, track.firstElementChild);
        }

        // force reflow so the browser applies the no-transition state
        track.offsetHeight; // eslint-disable-line no-unused-expressions

        track.style.transition = "";
        animating = false;
      };

      track.addEventListener("transitionend", onDone);
    };

    // Place track so that "current" is the middle slide at translateX(-100%)
    // We need 3 slides visible in the DOM order: prev, current, next.
    // So: move last slide to front, and set initial transform to -100%.
    const init = () => {
      if (track.children.length >= 2) {
        track.insertBefore(track.lastElementChild, track.firstElementChild);
      }
      track.style.transform = "translateX(-100%)";
      setActiveDot();
    };

    const next = () => rotateToIndex(index + 1, 1);
    const prev = () => rotateToIndex(index - 1, -1);

    // Dots: jump by choosing shortest direction (optional nice touch)
    dots.forEach((dot, i) => {
      dot.addEventListener("click", () => {
        if (i === index) return;
        const n = dots.length;
        const forward = normalize(i - index, n);
        const backward = normalize(index - i, n);
        // move one step at a time to keep the infinite animation consistent
        const steps = forward <= backward ? forward : backward;
        const dir = forward <= backward ? 1 : -1;

        let k = 0;
        const step = () => {
          if (k >= steps) return;
          rotateToIndex(index + dir, dir);
          k++;
          // wait for transition
          setTimeout(step, 340);
        };
        step();
      });
    });

    // Mouse wheel: one slide per wheel gesture
    let wheelLock = false;
    viewport.addEventListener(
      "wheel",
      (e) => {
        e.preventDefault();
        if (wheelLock || animating) return;
        wheelLock = true;
        if (e.deltaY > 0) next();
        else prev();
        setTimeout(() => (wheelLock = false), 360);
      },
      { passive: false }
    );

    // Drag / swipe
    let startX = 0;
    let dragging = false;

    const onDown = (clientX) => {
      if (animating) return;
      dragging = true;
      startX = clientX;
      viewport.setPointerCapture?.(event.pointerId);
    };

    const onMove = (clientX) => {
      if (!dragging || animating) return;
      const dx = clientX - startX;
      // You can add live dragging if you want; keeping it “snap on release” for cleanliness.
      // (No mid-drag transform = fewer weird edge cases.)
    };

    const onUp = (clientX) => {
      if (!dragging || animating) return;
      dragging = false;
      const dx = clientX - startX;
      const threshold = Math.min(80, viewport.clientWidth * 0.18);
      if (dx < -threshold) next();
      else if (dx > threshold) prev();
    };

    viewport.addEventListener("pointerdown", (e) => onDown(e.clientX));
    viewport.addEventListener("pointermove", (e) => onMove(e.clientX));
    viewport.addEventListener("pointerup", (e) => onUp(e.clientX));
    viewport.addEventListener("pointercancel", (e) => onUp(e.clientX));

    // Keyboard (optional but nice)
    window.addEventListener("keydown", (e) => {
      if (e.key === "ArrowRight") next();
      if (e.key === "ArrowLeft") prev();
    });

    init();
  </script>

  <style>
    .home-wrap{
      display:grid;
      gap: 16px;
      justify-items:start;
      align-items:start;
      margin-inline:auto;
      width:100%;
      padding-top: clamp(16px, 4vh, 48px);
      padding-bottom: clamp(24px, 6vh, 64px);
    }

    .projects{
      width: min(1200px, 100%);
    }

    .viewport{
      width: 100%;
      overflow: hidden;
      border-radius: 16px;
      touch-action: pan-y; /* allow vertical page scroll outside wheel handler */
    }

    /* Track shows 3 "panes": prev | current | next. Each pane is 100% width. */
    .track{
      display:flex;
      width: 300%;
      transform: translateX(-100%); /* current is centered */
    }

    .slide{
      width: 100%;
      flex: 0 0 100%;
      overflow:hidden;
    }

    .slide img{
      width:100%;
      height:auto;
      display:block;
      object-fit:cover;
    }

    .dots{
      margin-top: 0.9rem;
      display:flex;
      justify-content:center;
      gap: 10px;
    }
    .dot{
      width: 10px;
      height: 10px;
      border-radius: 999px;
      border: 0;
      background: currentColor;
      opacity: 0.35;
      cursor: pointer;
      transition: transform 160ms ease, opacity 160ms ease;
      position: relative;
    }
    .dot[data-active="true"]{
      opacity: 1;
      transform: scale(1.35);
    }
    .dot::before{
      content:"";
      position:absolute;
      inset:-10px;
    }
  </style>
</Layout>
