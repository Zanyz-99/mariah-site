---
import Layout from "../layouts/Layout.astro";

const slides = [
  "/projects/02 Project Two.png",
  "/projects/03 Project Three.png",
  "/projects/04 Project Four.png",
  "/projects/05 Project Five.png",
  "/projects/06 Project Six.png",
];

// We’ll render 3 copies for the “infinite” illusion
const copies = 3;
const total = slides.length * copies;
const middleStartIndex = slides.length; // start at the first slide of the middle copy
---

<Layout title="Home" description="">
  <section class="content home-wrap">
    <div class="projects">
      <div class="carousel" id="projects-carousel" aria-label="Projects carousel">
        <ul class="track" id="projects-track">
          {Array.from({ length: total }).map((_, i) => {
            const src = slides[i % slides.length];
            const logicalIndex = i % slides.length;
            return (
              <li class="slide" data-logical={logicalIndex}>
                <img
                  src={src}
                  alt={`Project ${logicalIndex + 1}`}
                  loading={i === middleStartIndex ? "eager" : "lazy"}
                  decoding="async"
                />
              </li>
            );
          })}
        </ul>

        <div class="dots" role="tablist" aria-label="Project slide navigation">
          {slides.map((_, i) => (
            <button
              class="dot"
              type="button"
              data-index={i}
              aria-label={`Go to slide ${i + 1}`}
            />
          ))}
        </div>
      </div>
    </div>
  </section>

  <script>
    const carousel = document.getElementById("projects-carousel");
    const track = document.getElementById("projects-track");
    const dots = carousel.querySelectorAll(".dot");
    const slideCount = dots.length;

    const clamp = (n, min, max) => Math.max(min, Math.min(max, n));

    let isAnimating = false;

    const slideWidth = () => track.clientWidth || 1;

    const setActiveDot = (logicalIdx) => {
      dots.forEach((d, i) => {
        if (i === logicalIdx) d.setAttribute("data-active", "true");
        else d.removeAttribute("data-active");
        d.setAttribute("aria-selected", i === logicalIdx ? "true" : "false");
      });
    };

    const scrollToPhysicalIndex = (physicalIdx, behavior = "smooth") => {
      isAnimating = true;
      track.scrollTo({ left: physicalIdx * slideWidth(), behavior });
      // release after a moment (covers smooth scroll)
      window.setTimeout(() => (isAnimating = false), behavior === "smooth" ? 280 : 0);
    };

    // --- Infinite illusion ---
    // Start in the middle copy so you can scroll both directions.
    const middleStart = slideCount; // first slide of middle copy
    const jumpIfNearEnds = () => {
      const w = slideWidth();
      const physical = Math.round(track.scrollLeft / w);

      // If we drift into the first copy, jump forward one copy
      if (physical < slideCount * 0.5) {
        const newPhysical = physical + slideCount;
        track.scrollLeft = newPhysical * w;
        return;
      }

      // If we drift into the last copy, jump back one copy
      if (physical > slideCount * 2.5) {
        const newPhysical = physical - slideCount;
        track.scrollLeft = newPhysical * w;
        return;
      }
    };

    const updateFromScroll = () => {
      const w = slideWidth();
      const physical = clamp(Math.round(track.scrollLeft / w), 0, Number.MAX_SAFE_INTEGER);
      const logical = ((physical % slideCount) + slideCount) % slideCount;
      setActiveDot(logical);
    };

    // Dots jump to the same logical slide within the middle copy
    dots.forEach((dot, logicalIdx) => {
      dot.addEventListener("click", () => {
        const physicalIdx = middleStart + logicalIdx;
        scrollToPhysicalIndex(physicalIdx, "smooth");
        setActiveDot(logicalIdx);
      });
    });

    // Mouse wheel: vertical scroll -> horizontal slide snapping
    // We move one full slide per wheel gesture (feels like “paging”).
    let wheelLock = false;
    carousel.addEventListener(
      "wheel",
      (e) => {
        // only when cursor is over carousel
        if (!carousel.matches(":hover")) return;

        // Prevent page from scrolling while interacting with carousel
        e.preventDefault();

        if (wheelLock || isAnimating) return;
        wheelLock = true;

        const w = slideWidth();
        const physical = Math.round(track.scrollLeft / w);
        const dir = e.deltaY > 0 ? 1 : -1;

        scrollToPhysicalIndex(physical + dir, "smooth");

        window.setTimeout(() => (wheelLock = false), 320);
      },
      { passive: false }
    );

    // Keep dots in sync + do infinite jumps
    track.addEventListener("scroll", () => {
      window.requestAnimationFrame(() => {
        jumpIfNearEnds();
        updateFromScroll();
      });
    });

    // Init: jump to middle copy instantly
    track.scrollLeft = middleStart * slideWidth();
    setActiveDot(0);
  </script>

  <style>
    .home-wrap{
      display:grid;
      gap: 16px;
      justify-items:start;
      align-items:start;
      margin-inline:auto;
      width:100%;
      padding-top: clamp(16px, 4vh, 48px);
      padding-bottom: clamp(24px, 6vh, 64px);
    }

    /* simple width cap without Carousel.astro */
    .projects{
      width: min(1200px, 100%);
    }

    .carousel{ width: 100%; }

    .track{
      display:flex;
      gap: 1rem;
      overflow-x:auto;
      scroll-snap-type:x mandatory;
      scroll-behavior:smooth;
      -webkit-overflow-scrolling:touch;
    }
    .track::-webkit-scrollbar{ display:none; }

    .slide{
      flex: 0 0 100%;
      width: 100%;
      scroll-snap-align:center;
      border-radius: 16px;
      overflow:hidden;
    }

    .slide img{
      width:100%;
      height:auto;
      display:block;
      object-fit:cover;
    }

    .dots{
      margin-top: 0.9rem;
      display:flex;
      justify-content:center;
      gap: 10px;
    }
    .dot{
      width: 10px;
      height: 10px;
      border-radius: 999px;
      border: 0;
      background: currentColor;
      opacity: 0.35;
      cursor: pointer;
      transition: transform 160ms ease, opacity 160ms ease;
      position: relative;
    }
    .dot[data-active="true"]{
      opacity: 1;
      transform: scale(1.35);
    }
    .dot::before{
      content:"";
      position:absolute;
      inset:-10px;
    }
  </style>
</Layout>
