---
import Layout from "../layouts/Layout.astro";

const slides = [
  "/projects/01 Project One.png",
  "/projects/02 Project Two.png",
  "/projects/03 Project Three.png",
  "/projects/04 Project Four.png",
  "/projects/05 Project Five.png",
  "/projects/06 Project Six.png",
];

// Covers (project name images)
const covers = [
  "/projects/Project Cover/Project One.png",
  "/projects/Project Cover/Project Two.png",
  "/projects/Project Cover/Project Three.png",
  "/projects/Project Cover/Project Four.png",
  "/projects/Project Cover/Project Five.png",
  "/projects/Project Cover/Project Six.png",
];
---

<Layout title="Home" description="">
  <section class="home">
    <div class="full-bleed">
      <div class="carousel" id="projects">
        <div class="viewport" id="viewport" tabindex="0" aria-label="Projects carousel">
          <div class="window" id="window">
            <ul class="track" id="track" aria-live="polite">
              <li class="card">
                <div class="media">
                  <img class="img-main" id="img-prev" alt="Previous project" decoding="async" />
                  <img class="img-cover" id="cover-prev" alt="" decoding="async" aria-hidden="true" />
                </div>
              </li>

              <li class="card is-active" id="card-cur">
                <div class="media">
                  <img class="img-main" id="img-cur" alt="Current project" decoding="async" />
                  <img class="img-cover" id="cover-cur" alt="" decoding="async" aria-hidden="true" />
                </div>
              </li>

              <li class="card">
                <div class="media">
                  <img class="img-main" id="img-next" alt="Next project" decoding="async" />
                  <img class="img-cover" id="cover-next" alt="" decoding="async" aria-hidden="true" />
                </div>
              </li>
            </ul>
          </div>
        </div>
        <!-- dots removed -->
      </div>
    </div>
  </section>

  <script define:vars={{ slides, covers }}>
    const viewport = document.getElementById("viewport");
    const track = document.getElementById("track");
    const cardCur = document.getElementById("card-cur");

    const imgPrev = document.getElementById("img-prev");
    const imgCur  = document.getElementById("img-cur");
    const imgNext = document.getElementById("img-next");

    const coverPrev = document.getElementById("cover-prev");
    const coverCur  = document.getElementById("cover-cur");
    const coverNext = document.getElementById("cover-next");

    const n = slides.length;
    const mod = (x) => (x % n + n) % n;

    let index = 0;
    let animating = false;
    let baseX = 0;

    // -------- Preload + decode helpers --------
    const preloaded = new Set();

    const preload = (src) => {
      if (!src || preloaded.has(src)) return;
      preloaded.add(src);
      const im = new Image();
      im.decoding = "async";
      im.src = src;
    };

    // Ensure browser has decoded image before we animate (prevents "pop in")
    const ensureDecoded = (imgEl, src) => {
      return new Promise((resolve) => {
        if (!imgEl) return resolve(false);

        // set src if needed
        if (imgEl.src !== new URL(src, window.location.href).href) {
          imgEl.src = src;
        }

        const done = () => {
          // decode if supported, otherwise resolve
          if (imgEl.decode) {
            imgEl.decode().then(() => resolve(true)).catch(() => resolve(true));
          } else {
            resolve(true);
          }
        };

        if (imgEl.complete && imgEl.naturalWidth > 0) return done();
        imgEl.addEventListener("load", done, { once: true });
        imgEl.addEventListener("error", () => resolve(false), { once: true });
      });
    };

    // Load + decode the trio (prev/cur/next) before we proceed
    const setAndDecodeImages = async () => {
      const prevI = slides[mod(index - 1)];
      const curI  = slides[index];
      const nextI = slides[mod(index + 1)];

      const prevC = covers[mod(index - 1)];
      const curC  = covers[index];
      const nextC = covers[mod(index + 1)];

      // start fetch early (even before we await)
      [prevI, curI, nextI, prevC, curC, nextC].forEach(preload);

      // assign sources
      imgPrev.src = prevI;
      imgCur.src  = curI;
      imgNext.src = nextI;

      coverPrev.src = prevC;
      coverCur.src  = curC;
      coverNext.src = nextC;

      // eager decode for these 6 elements
      imgPrev.loading = "eager";
      imgCur.loading  = "eager";
      imgNext.loading = "eager";
      coverPrev.loading = "eager";
      coverCur.loading  = "eager";
      coverNext.loading = "eager";

      await Promise.all([
        ensureDecoded(imgPrev, prevI),
        ensureDecoded(imgCur,  curI),
        ensureDecoded(imgNext, nextI),
        ensureDecoded(coverPrev, prevC),
        ensureDecoded(coverCur,  curC),
        ensureDecoded(coverNext, nextC),
      ]);

      // also preload further out in the background
      const farther = [
        slides[mod(index - 2)], slides[mod(index + 2)],
        covers[mod(index - 2)], covers[mod(index + 2)],
      ];
      farther.forEach(preload);
    };

    const gapPx = () => {
      const cs = getComputedStyle(track);
      return parseFloat(cs.columnGap || cs.gap || "0") || 0;
    };

    const cardWidth = () => {
      const card = track.querySelector(".card");
      return card ? card.getBoundingClientRect().width : 0;
    };

    const stepDistance = () => Math.round(cardWidth() + gapPx());

    const computeBaseX = () => {
      const v = viewport.getBoundingClientRect();
      const c = cardCur.getBoundingClientRect();

      const viewportCenter = v.left + v.width / 2;
      const cardCenter = c.left + c.width / 2;

      baseX += (viewportCenter - cardCenter);
      baseX = Math.round(baseX);

      track.style.transition = "none";
      track.style.transform = `translate3d(${baseX}px, 0, 0)`;
      track.offsetHeight;
    };

    // -------- Slide step (now decode-first) --------
    const step = async (dir) => {
      if (animating) return;
      animating = true;

      const dist = stepDistance();

      // compute target index first
      const nextIndex = mod(index + dir);

      // IMPORTANT: pre-decode the "incoming" trio BEFORE animating
      index = nextIndex;
      await setAndDecodeImages();

      // keep baseX centered (images swapped, layout stable)
      track.style.transition = "none";
      track.style.transform = `translate3d(${baseX}px, 0, 0)`;
      track.offsetHeight;
      computeBaseX();

      // now animate the movement (this moves to show new current)
      track.style.transition = "transform 320ms ease";
      track.style.transform = `translate3d(${baseX + (dir === 1 ? -dist : dist)}px, 0, 0)`;

      const onDone = () => {
        track.removeEventListener("transitionend", onDone);

        // snap back to base and re-center precisely
        track.style.transition = "none";
        track.style.transform = `translate3d(${baseX}px, 0, 0)`;
        track.offsetHeight;
        computeBaseX();

        animating = false;
      };

      track.addEventListener("transitionend", onDone);
    };

    // -------- Wheel works anywhere on page --------
    let wheelLock = false;
    window.addEventListener(
      "wheel",
      (e) => {
        e.preventDefault();
        if (wheelLock || animating) return;
        wheelLock = true;

        const dominant = Math.abs(e.deltaY) >= Math.abs(e.deltaX) ? e.deltaY : e.deltaX;
        step(dominant > 0 ? 1 : -1);

        setTimeout(() => (wheelLock = false), 380);
      },
      { passive: false }
    );

    // drag/swipe (viewport)
    let startX = 0;
    let dragging = false;

    viewport.addEventListener("pointerdown", (e) => {
      if (animating) return;
      dragging = true;
      startX = e.clientX;
      viewport.setPointerCapture?.(e.pointerId);
    });

    viewport.addEventListener("pointerup", (e) => {
      if (!dragging || animating) return;
      dragging = false;

      const dx = e.clientX - startX;
      const threshold = Math.min(90, viewport.clientWidth * 0.14);

      if (dx < -threshold) step(1);
      else if (dx > threshold) step(-1);
    });

    viewport.addEventListener("pointercancel", () => {
      dragging = false;
    });

    // keyboard (page-level)
    window.addEventListener("keydown", (e) => {
      if (animating) return;
      if (e.key === "ArrowRight") step(1);
      if (e.key === "ArrowLeft") step(-1);
    });

    // resize: recenter after layout settles
    let resizeT;
    window.addEventListener("resize", () => {
      clearTimeout(resizeT);
      resizeT = setTimeout(() => computeBaseX(), 60);
    });

    // init
    (async () => {
      // preload everything up front (best chance to avoid any pop)
      slides.forEach(preload);
      covers.forEach(preload);

      await setAndDecodeImages();

      requestAnimationFrame(() => {
        baseX = 0;
        track.style.transform = "translate3d(0,0,0)";
        computeBaseX();
      });
    })();
  </script>

  <style>
    :global(html),
    :global(body){
      height: 100%;
      margin: 0;
      overflow: hidden; /* no page scrollbars; wheel becomes slide nav */
    }

    .home{
      display: grid;
      gap: 16px;
      width: 100%;
      padding-top: clamp(12px, 3vh, 28px);
      padding-bottom: clamp(18px, 4vh, 44px);
    }

    .carousel{ width: 100%; }

    .viewport{
      width: 100%;
      overflow: hidden;
      outline: none;
      touch-action: pan-y;
      box-sizing: border-box;

      display: flex;
      justify-content: center;
      align-items: center;
    }

    .window{
      width: min(100vw, clamp(320px, 78vw, 980px));
      overflow: visible; /* allow next peek on desktop */
    }

    .track{
      display: flex;
      align-items: center;
      gap: clamp(10px, 2vw, 18px);
      padding: 6px 0;
      will-change: transform;
      transform: translate3d(0,0,0);
    }

    .card{
      flex: 0 0 auto;
      width: clamp(320px, 78vw, 980px);
      border-radius: 16px;
      overflow: hidden;

      aspect-ratio: 16 / 9;

      background: var(--card);
      border: 1px solid var(--border);

      opacity: 0.92;
      transition: opacity 200ms ease;
    }

    .card.is-active{ opacity: 1; }

    .media{
      position: relative;
      width: 100%;
      height: 100%;
    }

    .img-main,
    .img-cover{
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      object-fit: cover;
      object-position: center;
      user-select: none;
      -webkit-user-drag: none;
    }

    .img-main{
      filter: grayscale(100%) saturate(0.9);
      transition: filter 220ms ease;
    }

    .img-cover{
      opacity: 0.28;
      transition: opacity 220ms ease;
      pointer-events: none;
    }

    .card:hover .img-cover,
    .card:focus-within .img-cover{ opacity: 0; }

    .card:hover .img-main,
    .card:focus-within .img-main{ filter: none; }

    /* âœ… Mobile: go back to "no prev/next visible" + fit viewport */
    @media (max-width: 640px){
      .window{
        width: 100vw;
        overflow: hidden; /* hides prev/next */
      }

      .track{
        gap: 0;
        padding: 0;
      }

      .card{
        width: min(92vw, 520px);
        aspect-ratio: 9 / 16;
        border-radius: 14px;

        /* Fit inside visible viewport (svh handles address bar) */
        max-height: calc(100svh - 24px);
      }
    }

    @media (prefers-reduced-motion: reduce){
      .card,
      .img-main,
      .img-cover{
        transition: none !important;
      }
    }
  </style>
</Layout>
